initSidebarItems({"enum":[["ConsumerState","Holds the current state of the consumer"],["Err",""],["ErrorCode",""],["IResult","Holds the result of parsing functions"],["Needed",""],["ProducerState","Holds the data producer's current state"]],"fn":[["add_error_pattern",""],["alpha",""],["alphanumeric",""],["be_f32",""],["be_f64",""],["be_i16",""],["be_i32",""],["be_i64",""],["be_i8",""],["be_u16",""],["be_u32",""],["be_u64",""],["be_u8",""],["begin",""],["code_from_offset",""],["compare_error_paths",""],["digit",""],["eof",""],["error_to_list",""],["generate_colors",""],["is_alphabetic",""],["is_alphanumeric",""],["is_digit",""],["is_space",""],["le_i16",""],["le_i32",""],["le_i64",""],["le_i8",""],["le_u16",""],["le_u32",""],["le_u64",""],["le_u8",""],["length_value",""],["line_ending",""],["multispace",""],["not_line_ending",""],["prepare_errors",""],["print",""],["print_codes",""],["print_error",""],["print_offsets",""],["reset_color",""],["sized_buffer",""],["slice_to_offsets",""],["space",""],["tag_cl",""],["write_color",""]],"macro":[["alt!","try a list of parser, return the result of the first successful one"],["alt_parser!","Internal parser, do not use directly"],["apply!",""],["call!","Used to wrap common expressions and function as macros"],["chain!","chains parsers and assemble the results through a closure"],["chaining_parser!","Internal parser, do not use directly"],["closure!","Wraps a parser in a closure"],["cond!","Conditional combinator"],["count!","Applies the child parser a specified number of times"],["count_fixed!","Applies the child parser a fixed number of times and returns a fixed size array"],["dbg!","Prints a message if the parser fails"],["dbg_dmp!","Prints a message and the input if the parser fails"],["delimited!","delimited(opening, X, closing) returns X"],["error!","Prevents backtracking if the child parser fails"],["filter!","returns the longest list of bytes until the provided parser fails"],["flat_map!","flat_map! combines a parser R -> IResult<R,S> and a parser S -> IResult<S,T> to return another parser R -> IResult<R,T>"],["is_a!","returns the longest list of bytes that appear in the provided array"],["is_not!","returns the longest list of bytes that do not appear in the provided array"],["length_value!","returns"],["many0!","Applies the parser 0 or more times and returns the list of results in a Vec"],["many1!","Applies the parser 1 or more times and returns the list of results in a Vec"],["map!","maps a function on the result of a parser"],["map_opt!","maps a function returning an Option on the output of a parser"],["map_res!","maps a function returning a Result on the output of a parser"],["named!","Makes a function from a parser combination"],["opt!","make the underlying parser optional"],["pair!","pair(X,Y), returns (x,y)"],["peek!","returns a result without consuming the input"],["preceded!","preceded(opening, X) returns X"],["pusher!","Prepares a parser function for a push pipeline"],["separated_list!","separated_list(sep, X) returns Vec<X>"],["separated_nonempty_list!","separated_nonempty_list(sep, X) returns Vec<X>"],["separated_pair!","separated_pair(X,sep,Y) returns (x,y)"],["tag!","declares a byte array as a suite to recognize"],["take!","generates a parser consuming the specified number of bytes"],["take_str!","same as take! but returning a &str"],["take_until!",""],["take_until_and_consume!","generates a parser consuming bytes until the specified byte sequence is found"],["take_until_either!",""],["take_until_either_and_consume!",""],["terminated!","terminated(X, closing) returns X"]],"struct":[["FileProducer","Can produce data from a file"],["MemProducer","Can parse data from an already in memory byte array"]],"trait":[["AsBytes",""],["Consumer","Implement the consume method, taking a byte array as input and returning a consumer state"],["GetInput",""],["GetOutput",""],["HexDisplay",""],["Producer","A producer implements the produce method, currently working with u8 arrays"]]});